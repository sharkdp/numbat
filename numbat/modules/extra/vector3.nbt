use core::functions

struct Vec<D: Dim> {
    x: D,
    y: D,
    z: D,
}

impl<D: Dim> Vec<D> {
    @description("Compute the norm (squared length) of this vector.")
    fn norm(self) -> D^2 = self.x^2 + self.y^2 + self.z^2

    @description("Compute the length of this vector.")
    fn len(self) -> D = sqrt(self.norm())

    @description("Add another vector to this one.")
    fn add(self, other: Vec<D>) -> Vec<D> =
        Vec { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z }

    @description("Subtract another vector from this one.")
    fn sub(self, other: Vec<D>) -> Vec<D> =
        Vec { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z }

    @description("Negate this vector.")
    fn neg(self) -> Vec<D> =
        Vec { x: -self.x, y: -self.y, z: -self.z }

    @description("Compute the cross product with another vector.")
    fn cross<D2: Dim>(self, other: Vec<D2>) -> Vec<D * D2> =
        Vec {
            x: self.y * other.z - self.z * other.y,
            y: self.z * other.x - self.x * other.z,
            z: self.x * other.y - self.y * other.x,
        }

    @description("Compute the dot product with another vector.")
    fn dot<D2: Dim>(self, other: Vec<D2>) -> D * D2 =
        self.x * other.x + self.y * other.y + self.z * other.z

    @description("Multiply this vector by a scalar.")
    fn multiply<A: Dim>(self, scalar: A) -> Vec<D * A> =
        Vec { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar }
}

@description("Create a 3D vector from its components.")
fn vec<D: Dim>(x: D, y: D, z: D) -> Vec<D> =
    Vec { x: x, y: y, z: z }

