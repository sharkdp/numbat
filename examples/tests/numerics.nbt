use numerics::solve
use numerics::diff
use numerics::fixed_point

# Root finding

fn f1(x) = x³ - x - 2
assert_eq(root_bisect(f1, 1, 2, 1e-10, 1e-10), 1.52137970680, 1e-8)

fn f1_prime(x) = 3 x² - 1
assert_eq(root_newton(f1, f1_prime, 1, 1e-10), 1.52137970680, 1e-8)
assert_eq(root_newton(f1, f1_prime, 2, 1e-10), 1.52137970680, 1e-8)

# Fixed point iteration
let a = 3
fn f_sqrt3(x: Scalar) = 0.5 * (a / x + x)

assert_eq(fixed_point(f_sqrt3, 1, 1e-10), sqrt(3), 1e-10)

# Differentiation

assert_eq(diff(log, 2.0, 1e-10), 0.5, 1e-5)

assert_eq(diff(sin, 0.0, 1e-10), 1.0, 1e-5)

assert_eq(diff(sqrt, 1.0, 1e-10), 0.5, 1e-5)

fn f2(x: Scalar) -> Scalar = x² + 4 x + 1

assert_eq(diff(f2, 2.0, 1e-10), 8.0, 1e-5)

fn dist(t: Time) -> Length = 0.5 g0 t^2
fn velocity(t: Time) -> Velocity = diff(dist, t, 1e-10 s)

assert_eq(velocity(2.0 s), 2.0 s × g0, 1e-3 m/s)

# Differential equations

let t_min = 0 s
let t_max = 1 s
let n_points = 1_000

let μ = 0.7 / s
let x0 = 2 m

# Numerically solve x'(t) = μ x(t) with x(0) = x0.
# The exact solution is x(t) = x0 e^(μ t).
#
# 'ode(t, x)' is the right-hand side of the ODE.
fn ode(t, x) = μ x

fn exact_solution(t) = x0 exp(μ t)

# Fixed-step Runge-Kutta method
let result = dsolve_runge_kutta(ode, t_min, t_max, x0, n_points)

fn numerical_solution(t) = element_at(idx, result.ys)
  where t_range = t_max - t_min
    and idx = floor((t - t_min) / t_range * (n_points - 1))

assert_eq(numerical_solution(0 s), exact_solution(0 s))
assert_eq(numerical_solution(0.5 s), exact_solution(0.5 s), 1e-3 x0)
assert_eq(numerical_solution(1 s), exact_solution(1 s), 1e-3 x0)

# Adaptive RK45 solver (Dormand-Prince 5(4) method)
let result_rk45 = dsolve_adaptive_runge_kutta(ode, t_min, t_max, x0, 1e-10 m, 1e-8)
let y_final_rk45 = element_at(len(result_rk45.ys) - 1, result_rk45.ys)
assert_eq(y_final_rk45, exact_solution(t_max), 1e-6 x0)

# Test with zero initial condition (free fall)
fn freefall(t: Time, v: Velocity) -> Acceleration = -g0
let freefall_result = dsolve_adaptive_runge_kutta(freefall, 0 s, 2 s, 0 m/s, 1e-10 m/s, 1e-8)
let v_final = element_at(len(freefall_result.ys) - 1, freefall_result.ys)

assert_eq(v_final, -2 s × g0, 1e-6 m/s)
